name: Validate pull request

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize]
    paths:
      - 'force-app/**'

jobs:
  validate-deployment:
    runs-on: ubuntu-latest
    container:
      image: salesforce/cli:latest-slim
    steps:      
      - name: 'Checkout source code'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: 'Authenticate using SFDX_AUTH_URL'
        run: | 
          echo ${{ secrets.SFDX_AUTH_URL }} | sf org login sfdx-url -s -u

      - name: 'Install sfdx-git-delta'
        run: |
          sf plugins install sfdx-git-delta --force
          sf plugins

            - name: "Create delta packages for new, modified or deleted metadata"
              run: |
                  mkdir changed-sources
                  sf sgd:source:delta --to "HEAD" --from "HEAD^" --output changed-sources/ --generate-delta --source force-app/
          
          echo "âœ… Delta package created:"
          ls -R changed-sources/package || echo "âš ï¸ No package.xml found."

      - name: 'Validate'
        run: |
          if [ -f "changed-sources/package/package.xml" ]; then
            echo "ðŸš€ Validating only changed metadata..."
            sf project deploy validate \
              -x changed-sources/package/package.xml \
              -l RunLocalTests \
              -w 30
          else
            echo "âœ… No Salesforce changes detected, skipping validation."
          fi


# Jobs to be executed when the above conditions are met
jobs:
    # This is the name of the job. You can give it whatever name you want
    deployment-on-develop-org:
        # As mentioned in the blog post, this job runs inside a VM. Here we
        # can specify which OS this VM should run on.
        # In this case, we are going to run our commands on the latest version
        # of ubuntu
        runs-on: ubuntu-latest
        if: ${{ github.actor != 'dependabot[bot]' }}
        steps:
            # The idea is that the VM can access your remote repository
            # because your repository is an sfdx project.
            # This is a default action that allows us to enter the root
            # directory of the repository

            # Make sure to specify fetch-depth:0. This allows us to
            # access previous commits that have been pushed to the repository.

            # We'll need this later when we try to figure out which metadata has
            # changed between commits, so that we can only deploy that metadata
            # to the destination org

            - name: "Checkout source code"
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            # Store SFDX CLI in Cache
            - name: Cache SFDX CLI packages
              id: cache-sfdx
              uses: actions/cache@v3
              env:
                  cache-name: cache-sfdx-cli-modules
              with:
                  path: ~/sf
                  key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/sfdx-project.json') }}

            # Now Install Salesforce CLI
            - name: "Install Salesforce CLI"
              if: ${{ steps.cache-sfdx.outputs.cache-hit != 'true' }}
              run: |
                  wget https://developer.salesforce.com/media/salesforce-cli/sf/channels/stable/sf-linux-x64.tar.xz
                  mkdir -p ~/sf
                  tar xJf sf-linux-x64.tar.xz -C ~/sf --strip-components 1
                  echo "$HOME/sf/bin" >> $GITHUB_PATH
                  ~/sf/bin/sf version

            # Then we install the SFDX-Git-Delta plugin - https://github.com/scolladon/sfdx-git-delta
            # This is an awesome plugin that allows us to extract a package.xml with the metadata
            # that has changed between commits. I highly recommend going over the github readme
            # for more information on how this works.

            # Update SFDX CLI
            - name: "Update SFDX"
              if: ${{ steps.cache-sfdx.outputs.cache-hit == 'true' }}
              run: |
                  echo "$HOME/sf/bin" >> $GITHUB_PATH
                  ~/sf/bin/sf version

            - name: "Installing sfdx git delta"
              run: |
                  echo y | sf plugins:install sfdx-git-delta
                  sf plugins

            # Install SFDX scanner
            # - name: 'Installing SFDX scanner'
            #  run: sfdx plugins:install @salesforce/sfdx-scanner

            # Prior to setting up this workflow, you have to create a Github Secret
            # that contains the sfdx url of the integration/qa org.

            # The steps to generate the url are here
            # https://developer.salesforce.com/docs/atlas.en-us.sfdx_cli_reference.meta/sfdx_cli_reference/cli_reference_auth_sfdxurl.htm

            # This URL can then be used with the sfdx auth:sfdxurl:store to authenticate
            # the sfdx project in the repositry, against the org from which the URL
            # was generated from. This works just like that, there's no need to create
            # connected apps or any else.


            # Authenticate to org using the URL stored in the text file
            - name: "Authenticate using SFDX_AUTH_URL"
              run: echo ${{ secrets.SFDX_AUTH_URL }} | sf org login sfdx-url -s -u

            # We use SFDX Git Delta to create a directory with only the metadata that has changed.
            # this allows us to deploy only those changes, as opposed to deploying the entire branch.
            # This helps reducing deployment times
            - name: "Create delta packages for new, modified or deleted metadata"
              run: |
                  mkdir changed-sources
                  sf sgd:source:delta --to "HEAD" --from "HEAD^" --output changed-sources/ --generate-delta --source force-app/

            # Now we can use the sfdx scanner to scan the code in the delta directory
            # The output of the scan is stored in a file called apexScanResults.sarif

            # The .sarif file can later be uploaded to github, so that we can see the
            # results of the scan directly from the PR.

            #             - name: 'Scan code'
            #               run: |
            #                   cd changed-sources
            #                   sfdx scanner:run --format sarif --target './**/*.cls' --category "Design,Best Practices,Performance" --outfile 'apexScanResults.sarif'
            #                   cd ..

            #             # Now we upload the .sarif file as explained in the previous step
            #             - name: Upload SARIF file
            #               uses: github/codeql-action/upload-sarif@v1
            #               with:
            #                 sarif_file: changed-sources/apexScanResults.sarif

            # We do a check-only deploy and we only run the tests specified in the PR
            # If the env variable does not equal 'all', we know that there is a list of
            # tests that can be run

            # If the env variable equals all, we run all tests
            - name: "Deploy Delta Changes - No Tests Run"
              run: |
                  sf project deploy start --dry-run -x changed-sources/package/package.xml --post-destructive-changes changed-sources/destructiveChanges/destructiveChanges.xml -l NoTestRun --json

            # - name: 'Deploy destructive changes (if any)'
            #  run: sfdx force:mdapi:deploy -d "changed-sources/destructiveChanges" --checkonly --ignorewarnings
